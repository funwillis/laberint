<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Labyrinth - Tile Game</title>
  <!-- Using the Cinzel font for a classical Greek feel -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel&display=swap" rel="stylesheet">
  <style>
    /* =================== General Styles =================== */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Cinzel', serif;
      background: linear-gradient(135deg, #fdfcfb, #e2d1c3);
      color: #3e2723;
    }
    /* =================== Layout: 3 Columns =================== */
    #game-container {
      display: flex;
      height: 100vh;
      box-sizing: border-box;
      padding: 5px;
    }
    /* Left Panel: Controls */
    #control-panel {
      width: 300px;
      padding: 15px;
      background: #f8f1e4;
      border-right: 4px solid #8d6e63;
      box-shadow: 4px 0 10px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #control-panel h2, #control-panel h3 {
      color: #5d4037;
      margin: 5px 0;
    }
    #control-panel h2 {
      font-size: 24px;
    }
    #turn-info {
      margin-bottom: 10px;
    }
    /* Center Panel: Message and Board */
    #board-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 10px;
    }
    #message {
      margin-bottom: 15px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
      min-height: 40px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(12, 50px);
      grid-template-rows: repeat(12, 50px);
      gap: 2px;
      background: #333;
      padding: 10px;
      border: 4px solid #8d6e63;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      position: relative;
    }
    .cell {
      width: 50px;
      height: 50px;
      background: #fff;
      position: relative;
      box-shadow: inset 0 0 2px #999;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .cell.highlight {
      background: #c8e6c9;
    }
    .cell-coord {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 10px;
      color: #666;
      z-index: 10;
    }
    /* =================== Tile Visuals =================== */
    .tile {
      width: 100%;
      height: 100%;
      background-size: cover;
      background-repeat: no-repeat;
      display: block;
      margin: auto;
    }
    .tile-deadend {
      /* "tancat": stroke extends to y=60 with horizontal stroke at y=60 */
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><line x1='50' y1='0' x2='50' y2='60' stroke='%235d4037' stroke-width='20' stroke-linecap='round'/><line x1='40' y1='60' x2='60' y2='60' stroke='%235d4037' stroke-width='20' stroke-linecap='round'/></svg>");
      background-size: 100% 100%;
      background-repeat: no-repeat;
    }
    .tile-cross {
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='40' y='0' width='20' height='100' fill='%235d4037'/><rect x='0' y='40' width='100' height='20' fill='%235d4037'/></svg>");
    }
    .tile-straight {
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='40' y='0' width='20' height='100' fill='%235d4037'/></svg>");
    }
    .tile-t {
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='40' y='0' width='20' height='60' fill='%235d4037'/><rect x='0' y='40' width='100' height='20' fill='%235d4037'/></svg>");
    }
    .tile-curve {
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='40' y='0' width='20' height='50' fill='%235d4037'/><rect x='50' y='40' width='50' height='20' fill='%235d4037'/></svg>");
    }
    /* Special Tiles */
    .tile-entrance {
      background-color: #a5d6a7;
      border: 2px solid #388e3c;
      border-radius: 4px;
    }
    .tile-exit {
      background-color: #ef9a9a;
      border: 2px solid #d32f2f;
      border-radius: 4px;
    }
    .tile-treasure {
      background-color: #ffe082;
      border: 2px solid #fbc02d;
      border-radius: 4px;
    }
    .tile-minotaur {
      background-color: #ce93d8;
      border: 2px solid #8e24aa;
      border-radius: 4px;
    }
    /* =================== Player Marker =================== */
    .player {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 2px solid #fff;
      box-shadow: 0 0 3px rgba(0,0,0,0.7);
      z-index: 15;
    }
    .player.player1 { background: #2196F3; }
    .player.player2 { background: #4CAF50; }
    .player.player3 { background: #FF9800; }
    /* =================== Control Panel (Left) =================== */
    #tile-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      margin-top: 15px;
    }
    /* New Move Controls */
    #move-controls {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      margin-top: 15px;
    }
    #skip-move-btn {
      padding: 10px 15px;
      background: #8d6e63;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s ease;
    }
    #skip-move-btn:hover { background: #6d4c41; }
    #tile-preview-container {
      width: 60px;
      height: 60px;
      margin: 10px;
      border: 2px dashed #8d6e63;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
    }
    #tile-preview {
      width: 100%;
      height: 100%;
      background-size: cover;
      background-repeat: no-repeat;
      display: block;
    }
    /* =================== Right Panel: Configuration and Event Log =================== */
    #log-panel {
      width: 550px;
      display: flex;
      flex-direction: column;
      height: 100%;
      border-left: 4px solid #8d6e63;
      box-shadow: -4px 0 10px rgba(0,0,0,0.3);
    }
    #config-panel {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      border-bottom: 1px solid #8d6e63;
    }
    #config-panel h3 {
      margin-top: 0;
      text-align: center;
    }
    /* Configuration Buttons */
    #config-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }
    #config-table {
      width: 100%;
      border-collapse: collapse;
    }
    #config-table th, #config-table td {
      border: 1px solid #8d6e63;
      padding: 5px;
      text-align: center;
    }
    /* Set input width to exactly match the four arrow buttons (4 x 16px = 64px) */
    #config-table input {
      width: 64px;
    }
    /* Wrap each input in a container that also holds the arrow gizmos */
    .input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .arrow-container {
      display: flex;
      justify-content: center;
      gap: 2px;
      margin-top: 2px;
      flex-wrap: wrap;
    }
    .arrow-btn {
      font-size: 10px;
      line-height: 1;
      padding: 2px;
      width: 16px;
      height: 16px;
      text-align: center;
      border: 1px solid #8d6e63;
      background: #f8f1e4;
      cursor: pointer;
    }
    /* =================== Event Log =================== */
    #event-log-container {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
    }
    #event-log-container h3 {
      margin-top: 0;
      text-align: center;
    }
    #event-log {
      width: 100%;
    }
    /* =================== Game Buttons (Below Board) =================== */
    #game-buttons {
      margin-top: 15px;
      text-align: center;
    }
    .btn {
      padding: 10px 15px;
      margin: 10px;
      background: #8d6e63;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s ease;
    }
    .btn:hover { background: #6d4c41; }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Left Panel: Controls -->
    <div id="control-panel">
      <div id="tile-controls">
        <h3>Peça Obtinguda</h3>
        <div id="tile-preview-container">
          <div id="tile-preview"></div>
        </div>
        <button id="rotate-btn" class="btn">Gira 90º</button>
        <button id="confirm-tile-btn" class="btn">Confirma peça</button>
      </div>
      <div id="move-controls">
        <button id="skip-move-btn" class="btn">Ometre moviment</button>
      </div>
    </div>
    <!-- Center Panel: Message and Board -->
    <div id="board-container">
      <div id="message"></div>
      <div id="board"></div>
    </div>
    <!-- Right Panel: Configuration and Event Log -->
    <div id="log-panel">
      <div id="config-panel">
        <h3>Configuració Inicial</h3>
        <table id="config-table">
          <thead>
            <tr>
              <th>Tipus</th>
              <th>Previsualització</th>
              <th>Jugador 1</th>
              <th>Jugador 2</th>
              <th>Jugador 3</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Cruce</td>
              <td class="preview-cell"><div class="tile tile-cross" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="cross">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="cross">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="cross">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
            <!-- Similar structure for the remaining tile types (Curva, Bifurcació, Recta, Tancat) -->
            <tr>
              <td>Curva</td>
              <td class="preview-cell"><div class="tile tile-curve" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="curve">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="curve">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="curve">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
            <tr>
              <td>Bifurcació</td>
              <td class="preview-cell"><div class="tile tile-t" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="t">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="t">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="t">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
            <tr>
              <td>Recta</td>
              <td class="preview-cell"><div class="tile tile-straight" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="straight">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="straight">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="straight">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
            <tr>
              <td>Tancat</td>
              <td class="preview-cell"><div class="tile tile-deadend" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="deadend">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="deadend">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="deadend">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
        <div id="config-buttons">
          <button id="config-start-btn" class="btn">Iniciar</button>
          <button id="config-reset-btn" class="btn" disabled>Reinicia</button>
        </div>
      </div>
      <div id="event-log-container">
        <h3>Log d'Events</h3>
        <div id="event-log"></div>
      </div>
    </div>
  </div>

  <script>
    // Propagation functions using closest() and proper row indices
    function propagateLeft(btn) {
      let td = btn.closest("td");
      let input = td.querySelector("input");
      let value = input.value;
      let tr = td.closest("tr");
      let cells = Array.from(tr.cells);
      let currentIndex = td.cellIndex;
      cells.forEach((cell, index) => {
        if (index < currentIndex) {
          let inp = cell.querySelector("input");
          if (inp) { inp.value = value; }
        }
      });
    }
    function propagateRight(btn) {
      let td = btn.closest("td");
      let input = td.querySelector("input");
      let value = input.value;
      let tr = td.closest("tr");
      let cells = Array.from(tr.cells);
      let currentIndex = td.cellIndex;
      cells.forEach((cell, index) => {
        if (index > currentIndex) {
          let inp = cell.querySelector("input");
          if (inp) { inp.value = value; }
        }
      });
    }
    function propagateUp(btn) {
      let td = btn.closest("td");
      let input = td.querySelector("input");
      let value = input.value;
      let tr = td.closest("tr");
      let tbody = tr.closest("tbody");
      let rows = Array.from(tbody.rows);
      let currentRowIndex = tr.sectionRowIndex;
      rows.forEach((row, index) => {
        if (index < currentRowIndex) {
          let cell = row.cells[td.cellIndex];
          if (cell) {
            let inp = cell.querySelector("input");
            if (inp) { inp.value = value; }
          }
        }
      });
    }
    function propagateDown(btn) {
      let td = btn.closest("td");
      let input = td.querySelector("input");
      let value = input.value;
      let tr = td.closest("tr");
      let tbody = tr.closest("tbody");
      let rows = Array.from(tbody.rows);
      let currentRowIndex = tr.sectionRowIndex;
      rows.forEach((row, index) => {
        if (index > currentRowIndex) {
          let cell = row.cells[td.cellIndex];
          if (cell) {
            let inp = cell.querySelector("input");
            if (inp) { inp.value = value; }
          }
        }
      });
    }
    
    window.onload = function() {
      // Mapping of internal tile types to Catalan names
      const tileNamesCat = {
        cross: "creu",
        curve: "angle recte",
        t: "bifurcació",
        straight: "recta",
        deadend: "tancat"
      };
      
      // Base definitions for normal tiles
      const baseTiles = {
        cross: { edges: { N: true, E: true, S: true, W: true } },
        curve: { edges: { N: true, E: true, S: false, W: false } },
        t: { edges: { N: true, E: true, S: false, W: true } },
        straight: { edges: { N: true, E: false, S: true, W: false } },
        deadend: { edges: { N: true, E: false, S: false, W: false } }
      };

      // -------------------- Tile Class --------------------
      class Tile {
        constructor(type, edges, special = null) {
          this.type = type;
          this.edges = Object.assign({}, edges);
          this.special = special;
          this.rotation = 0;
        }
        rotate() {
          const { N, E, S, W } = this.edges;
          this.edges = { N: W, E: N, S: E, W: S };
          this.rotation = (this.rotation + 90) % 360;
        }
        clone() {
          const newTile = new Tile(this.type, Object.assign({}, this.edges), this.special);
          newTile.rotation = this.rotation;
          return newTile;
        }
      }
      
      // -------------------- Cell Class --------------------
      class Cell {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.tile = null;
          this.player = null;
        }
      }
      
      // -------------------- Player Class --------------------
      class Player {
        constructor(name, x, y, cssClass) {
          this.name = name;
          this.x = x;
          this.y = y;
          this.cssClass = cssClass;
          this.pool = {};
        }
      }
      
      // -------------------- Main Game Class --------------------
      class Game {
        constructor() {
          this.size = 12;
          this.board = [];
          this.players = [];
          this.currentPlayerIndex = 0;
          this.phase = "idle"; // "idle", "rotate", "place", "move"
          this.validCells = [];
          this.activeTile = null;
          this.events = [];
          this.initBoard();
          this.initSpecialTiles();
          this.initPlayers();
          this.renderBoard();
          this.updateTurnInfo();
          this.logEvent("Inici del joc");
        }
        initBoard() {
          for (let y = 1; y <= this.size; y++) {
            const row = [];
            for (let x = 1; x <= this.size; x++) {
              row.push(new Cell(x, y));
            }
            this.board.push(row);
          }
        }
        initSpecialTiles() {
          const placeSpecial = (x, y, specialType, baseType, edges) => {
            const cell = this.getCell(x, y);
            cell.tile = new Tile(baseType, edges, specialType);
          };
          placeSpecial(1, 12, 'entrance', 'entrance', {N: true, E: true, S: false, W: false});
          placeSpecial(12, 1, 'entrance', 'entrance', {N: false, E: false, S: true, W: true});
          placeSpecial(12, 12, 'entrance', 'entrance', {N: true, E: false, S: false, W: true});
          placeSpecial(1, 1, 'exit', 'exit', {N: false, E: true, S: true, W: false});
          [[4,4], [4,9], [9,4], [9,9]].forEach(coord => {
            placeSpecial(coord[0], coord[1], 'treasure', 'treasure', {N: true, E: false, S: false, W: false});
          });
          [[6,6], [6,7], [7,6], [7,7]].forEach(coord => {
            placeSpecial(coord[0], coord[1], 'minotaur', 'minotaur', {N: true, E: true, S: true, W: false});
          });
        }
        initPlayers() {
          this.players.push(new Player("Jugador 1", 1, 12, "player1"));
          this.players.push(new Player("Jugador 2", 12, 1, "player2"));
          this.players.push(new Player("Jugador 3", 12, 12, "player3"));
          this.players.forEach(p => {
            this.getCell(p.x, p.y).player = p;
          });
        }
        getCell(x, y) {
          if (x < 1 || x > this.size || y < 1 || y > this.size) return null;
          return this.board[y - 1][x - 1];
        }
        renderBoard() {
          const boardDiv = document.getElementById("board");
          boardDiv.innerHTML = "";
          for (let y = 1; y <= this.size; y++) {
            for (let x = 1; x <= this.size; x++) {
              const cell = this.getCell(x, y);
              const cellDiv = document.createElement("div");
              cellDiv.classList.add("cell");
              cellDiv.dataset.x = x;
              cellDiv.dataset.y = y;
              const coordSpan = document.createElement("span");
              coordSpan.classList.add("cell-coord");
              coordSpan.innerText = x + "," + y;
              cellDiv.appendChild(coordSpan);
              if (cell.tile) {
                const tileDiv = document.createElement("div");
                tileDiv.classList.add("tile");
                if (cell.tile.special) {
                  tileDiv.classList.add("tile-" + cell.tile.special);
                } else {
                  tileDiv.classList.add("tile-" + cell.tile.type);
                }
                tileDiv.style.transform = "rotate(" + cell.tile.rotation + "deg)";
                cellDiv.appendChild(tileDiv);
              }
              if (this.validCells.find(c => c.x === x && c.y === y)) {
                cellDiv.classList.add("highlight");
              }
              if (cell.player) {
                const playerDiv = document.createElement("div");
                playerDiv.classList.add("player", cell.player.cssClass);
                cellDiv.appendChild(playerDiv);
              }
              cellDiv.addEventListener("click", () => this.handleCellClick(x, y));
              boardDiv.appendChild(cellDiv);
            }
          }
        }
        updateTurnInfo() {
          const infoDiv = document.getElementById("turn-info");
          if (infoDiv) {
            const currentPlayer = this.getCurrentPlayer();
            infoDiv.innerHTML = `<p>Torn actiu: ${currentPlayer.name}</p>`;
          }
        }
        setMessage(msg) {
          document.getElementById("message").innerText = msg;
        }
        logEvent(message) {
          const snapshot = this.saveState();
          this.events.unshift({ message, snapshot });
          this.updateLog();
          updateConfigTable();
        }
        updateLog() {
          const logDiv = document.getElementById("event-log");
          logDiv.innerHTML = "";
          this.events.forEach((evt, index) => {
            const entry = document.createElement("div");
            entry.style.borderBottom = "1px solid #8d6e63";
            entry.style.padding = "5px";
            entry.style.display = "flex";
            entry.style.justifyContent = "space-between";
            entry.style.alignItems = "center";
            const msgSpan = document.createElement("span");
            msgSpan.innerText = evt.message;
            const rewindBtn = document.createElement("button");
            rewindBtn.className = "btn";
            rewindBtn.style.padding = "2px 5px";
            rewindBtn.style.fontSize = "12px";
            rewindBtn.innerText = "Rebobina";
            rewindBtn.onclick = () => { this.rewindToEvent(index); };
            entry.appendChild(msgSpan);
            entry.appendChild(rewindBtn);
            logDiv.appendChild(entry);
          });
        }
        toggleLog() { }
        rewindToEvent(index) {
          const evt = this.events[index];
          if (evt) {
            this.restoreState(evt.snapshot);
            this.logEvent("Rebobinat a: " + evt.message);
          }
        }
        saveState() {
          return {
            currentPlayerIndex: this.currentPlayerIndex,
            phase: this.phase,
            board: this.board.map(row => row.map(cell => ({
              x: cell.x,
              y: cell.y,
              tile: cell.tile ? {
                type: cell.tile.type,
                edges: Object.assign({}, cell.tile.edges),
                special: cell.tile.special,
                rotation: cell.tile.rotation
              } : null,
              player: cell.player ? {
                name: cell.player.name,
                x: cell.player.x,
                y: cell.player.y,
                cssClass: cell.player.cssClass
              } : null
            }))),
            players: this.players.map(p => ({
              name: p.name,
              x: p.x,
              y: p.y,
              cssClass: p.cssClass,
              pool: Object.assign({}, p.pool)
            })),
            activeTile: this.activeTile ? {
              type: this.activeTile.type,
              edges: Object.assign({}, this.activeTile.edges),
              special: this.activeTile.special,
              rotation: this.activeTile.rotation
            } : null
          };
        }
        restoreState(state) {
          this.currentPlayerIndex = state.currentPlayerIndex;
          this.phase = state.phase;
          this.board = state.board.map(rowData => {
            return rowData.map(cellData => {
              const cell = new Cell(cellData.x, cellData.y);
              if (cellData.tile) {
                cell.tile = new Tile(cellData.tile.type, cellData.tile.edges, cellData.tile.special);
                cell.tile.rotation = cellData.tile.rotation;
              }
              if (cellData.player) {
                cell.player = new Player(cellData.player.name, cellData.player.x, cellData.player.y, cellData.player.cssClass);
                cell.player.pool = Object.assign({}, cellData.player.pool);
              }
              return cell;
            });
          });
          this.players = state.players.map(pData => {
            let p = new Player(pData.name, pData.x, pData.y, pData.cssClass);
            p.pool = Object.assign({}, pData.pool);
            return p;
          });
          if (state.activeTile) {
            this.activeTile = new Tile(state.activeTile.type, state.activeTile.edges, state.activeTile.special);
            this.activeTile.rotation = state.activeTile.rotation;
          } else {
            this.activeTile = null;
          }
          this.renderBoard();
          this.updateTurnInfo();
        }
        getCurrentPlayer() {
          return this.players[this.currentPlayerIndex];
        }
        getCurrentPlayerCell() {
          const p = this.getCurrentPlayer();
          return this.getCell(p.x, p.y);
        }
        getAdjacentCoords(x, y) {
          return [
            { x: x, y: y - 1, dir: "N" },
            { x: x + 1, y: y, dir: "E" },
            { x: x, y: y + 1, dir: "S" },
            { x: x - 1, y: y, dir: "W" }
          ].filter(coord => this.getCell(coord.x, coord.y) !== null);
        }
        getDirection(from, to) {
          if (to.x === from.x && to.y === from.y - 1) return "N";
          if (to.x === from.x + 1 && to.y === from.y) return "E";
          if (to.x === from.x && to.y === from.y + 1) return "S";
          if (to.x === from.x - 1 && to.y === from.y) return "W";
          return null;
        }
        getOpposite(dir) {
          const opposites = { N: "S", E: "W", S: "N", W: "E" };
          return opposites[dir];
        }
        isActiveTilePlaceable() {
          if (!this.activeTile) return false;
          return this.getExplorableCells().length > 0;
        }
        getExplorableCells() {
          const current = this.getCurrentPlayerCell();
          const adj = this.getAdjacentCoords(current.x, current.y);
          return adj.filter(coord => {
            const cell = this.getCell(coord.x, coord.y);
            if (!cell || cell.tile) return false;
            return current.tile.edges[coord.dir] && this.activeTile.edges[this.getOpposite(coord.dir)];
          });
        }
        getMovableCells() {
          const current = this.getCurrentPlayerCell();
          const currentTile = current.tile;
          if (!currentTile) return [];
          const adj = this.getAdjacentCoords(current.x, current.y);
          return adj.filter(coord => {
            const cell = this.getCell(coord.x, coord.y);
            if (!cell || !cell.tile) return false;
            const dir = this.getDirection(current, coord);
            return currentTile.edges[dir] && cell.tile.edges[this.getOpposite(dir)];
          });
        }
        anyRotationValid() {
          let current = this.getCurrentPlayerCell();
          let freeAdj = this.getAdjacentCoords(current.x, current.y).filter(coord => {
            let cell = this.getCell(coord.x, coord.y);
            return cell && !cell.tile;
          });
          for (let i = 0; i < 4; i++) {
            let testTile = this.activeTile.clone();
            for (let j = 0; j < i; j++) {
              testTile.rotate();
            }
            for (let coord of freeAdj) {
              if (current.tile.edges[coord.dir] && testTile.edges[this.getOpposite(coord.dir)]) {
                return true;
              }
            }
          }
          return false;
        }
        validateActiveTile() {
          if (this.activeTile) {
            if (!this.anyRotationValid()) {
              document.getElementById("confirm-tile-btn").disabled = true;
              // Apply red border to the container
              document.getElementById("tile-preview-container").style.border = "2px solid red";
              document.getElementById("move-controls").style.display = "flex";
              document.getElementById("tile-controls").style.display = "none";
              this.setMessage("Torn de " + this.getCurrentPlayer().name + ". La peça " + tileNamesCat[this.activeTile.type] + " no es pot col·locar en cap orientació. Prem 'Ometre moviment' per retornar-la.");
            } else {
              document.getElementById("confirm-tile-btn").disabled = false;
              // Restore normal border
              document.getElementById("tile-preview-container").style.border = "2px dashed #8d6e63";
            }
          }
        }
        rotateActiveTile() {
          if (this.activeTile && this.phase === "rotate") {
            this.activeTile.rotate();
            this.updateTilePreview();
            if (!this.isActiveTilePlaceable()) {
              document.getElementById("confirm-tile-btn").disabled = true;
              document.getElementById("tile-preview-container").style.border = "2px solid red";
              this.setMessage("Torn de " + this.getCurrentPlayer().name + ". Peça " + tileNamesCat[this.activeTile.type] + " amb aquesta orientació no és vàlida.");
            } else {
              document.getElementById("confirm-tile-btn").disabled = false;
              document.getElementById("tile-preview-container").style.border = "2px dashed #8d6e63";
              this.setMessage("Torn de " + this.getCurrentPlayer().name + ". Peça " + tileNamesCat[this.activeTile.type] + " obtinguda. Pots girar-la i confirmar-la.");
            }
          }
        }
        updateTilePreview() {
          const preview = document.getElementById("tile-preview");
          preview.innerHTML = "";
          preview.style.border = "none";
          if (this.activeTile) {
            const tileElem = document.createElement("div");
            tileElem.classList.add("tile");
            if (this.activeTile.type === "deadend") {
              tileElem.classList.add("tile-deadend");
            } else if (this.activeTile.special) {
              tileElem.classList.add("tile-" + this.activeTile.special);
            } else {
              tileElem.classList.add("tile-" + this.activeTile.type);
            }
            tileElem.style.transform = "rotate(" + this.activeTile.rotation + "deg)";
            preview.appendChild(tileElem);
          }
        }
        drawTile() {
          let pool = this.getCurrentPlayer().pool;
          let total = 0;
          for (let type in pool) {
            total += pool[type];
          }
          if (total <= 0) {
            return null;
          }
          let rnd = Math.random() * total;
          let chosenType = null;
          for (let type in pool) {
            if (pool[type] > 0) {
              if (rnd < pool[type]) {
                chosenType = type;
                break;
              }
              rnd -= pool[type];
            }
          }
          this.getCurrentPlayer().pool[chosenType]--;
          let tile = new Tile(chosenType, baseTiles[chosenType].edges);
          let rotations = Math.floor(Math.random() * 4);
          for (let i = 0; i < rotations; i++) {
            tile.rotate();
          }
          return tile;
        }
        startTurn() {
          const current = this.getCurrentPlayerCell();
          const freeAdjacent = this.getAdjacentCoords(current.x, current.y).filter(coord => {
            const cell = this.getCell(coord.x, coord.y);
            return cell && !cell.tile;
          });
          if (freeAdjacent.length === 0) {
            // No free adjacent cells for placement
            this.phase = "move";
            this.validCells = this.getMovableCells();
            document.getElementById("tile-controls").style.display = "none";
            document.getElementById("move-controls").style.display = "flex";
            this.setMessage("No hi ha caselles disponibles per col·locar la peça. Prem 'Ometre moviment' per continuar.");
            this.logEvent("Jugador " + this.getCurrentPlayer().name + ": no hi ha caselles per col·locar la peça");
            this.renderBoard();
            return;
          }
          this.phase = "rotate";
          this.activeTile = this.drawTile();
          if (!this.activeTile) {
            this.setMessage("No tens més peces per explorar.");
            return;
          }
          document.getElementById("tile-controls").style.display = "flex";
          document.getElementById("move-controls").style.display = "none";
          this.updateTilePreview();
          this.validateActiveTile();
          this.setMessage("Torn de " + this.getCurrentPlayer().name + ". Peça obtinguda: " + tileNamesCat[this.activeTile.type] + ". Pots girar-la i confirmar-la.");
          document.getElementById("confirm-tile-btn").disabled = !this.isActiveTilePlaceable();
        }
        confirmTile() {
          if (this.activeTile && this.phase === "rotate") {
            if (!this.isActiveTilePlaceable()) {
              this.setMessage("La peça no es pot col·locar en cap casella.");
              return;
            }
            this.phase = "place";
            this.validCells = this.getExplorableCells();
            if (this.validCells.length === 0) {
              this.setMessage("No hi ha caselles vàlides per col·locar la peça. Torn perdut.");
              this.endTurn();
            } else {
              this.setMessage("Explora: tria una casella adjacent per col·locar la peça.");
            }
            document.getElementById("tile-controls").style.display = "none";
            this.renderBoard();
          }
        }
        handleCellClick(x, y) {
          if (this.phase === "place") {
            if (!this.validCells.find(c => c.x === x && c.y === y)) return;
            const cell = this.getCell(x, y);
            cell.tile = this.activeTile;
            const currentPlayer = this.getCurrentPlayer();
            const remaining = currentPlayer.pool[this.activeTile.type] || 0;
            this.logEvent("Jugador " + currentPlayer.name + ": Peça " + tileNamesCat[this.activeTile.type] + " col·locada a (" + x + "," + y + "). Queden: " + remaining);
            this.activeTile = null;
            this.validCells = [];
            this.phase = "move";
            this.validCells = this.getMovableCells();
            document.getElementById("tile-controls").style.display = "none";
            document.getElementById("move-controls").style.display = "flex";
            if (this.validCells.length === 0) {
              this.setMessage("Peça col·locada. No hi ha moviments disponibles. Fi de torn.");
              this.renderBoard();
              this.logEvent("Jugador " + currentPlayer.name + ": Peça col·locada sense moviments");
              setTimeout(() => this.endTurn(), 1000);
            } else {
              this.setMessage("Peça col·locada. Ara tria on vols moure't.");
            }
            this.renderBoard();
          } else if (this.phase === "move") {
            if (!this.validCells.find(c => c.x === x && c.y === y)) return;
            const currentPlayer = this.getCurrentPlayer();
            this.getCell(currentPlayer.x, currentPlayer.y).player = null;
            currentPlayer.x = x;
            currentPlayer.y = y;
            this.getCell(x, y).player = currentPlayer;
            this.setMessage("El jugador " + currentPlayer.name + " s'ha mogut a (" + x + "," + y + "). Fi de torn.");
            this.renderBoard();
            this.logEvent("Jugador " + currentPlayer.name + " mogut a (" + x + "," + y + ")");
            setTimeout(() => this.endTurn(), 1000);
          }
        }
        endTurn() {
          this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;
          setTimeout(() => { this.startTurn(); }, 1000);
        }
      }
      
      // -------------------- Configuration Logic --------------------
      function readConfiguration() {
        const inputs = document.querySelectorAll("#config-table input");
        let pools = { "Jugador 1": {}, "Jugador 2": {}, "Jugador 3": {} };
        inputs.forEach(input => {
          const type = input.getAttribute("data-type");
          let td = input.closest("td");
          let cellIndex = td ? td.cellIndex : -1;
          let player;
          if(cellIndex === 2) player = "Jugador 1";
          else if(cellIndex === 3) player = "Jugador 2";
          else if(cellIndex === 4) player = "Jugador 3";
          if (player) { pools[player][type] = parseInt(input.value, 10); }
        });
        return pools;
      }
      
      function disableConfiguration() {
        const inputs = document.querySelectorAll("#config-table input");
        inputs.forEach(input => input.disabled = true);
        document.getElementById("config-start-btn").disabled = true;
      }
      
      function enableConfigurationButtons(startEnabled) {
        document.getElementById("config-start-btn").disabled = !startEnabled;
        document.getElementById("config-reset-btn").disabled = startEnabled;
      }
      
      function updateConfigTable() {
        let inputs = document.querySelectorAll("#config-table input");
        inputs.forEach(input => {
          let type = input.getAttribute("data-type");
          let td = input.closest("td");
          let playerIndex = td.cellIndex - 2;
          if (game && game.players && game.players[playerIndex]) {
            input.value = game.players[playerIndex].pool[type];
          }
        });
      }
      
      // -------------------- Game Initialization --------------------
      let game;
      function startGame() {
        const pools = readConfiguration();
        game.players.forEach(player => {
          player.pool = Object.assign({}, pools[player.name]);
        });
        disableConfiguration();
        enableConfigurationButtons(false);
        game.startTurn();
      }
      
      function resetGame() {
        location.reload();
      }
      
      // -------------------- Initialize Game Instance --------------------
      game = new Game();
      
      // -------------------- Button Event Listeners --------------------
      document.getElementById("rotate-btn").addEventListener("click", () => {
        game.rotateActiveTile();
        game.validateActiveTile();
      });
      document.getElementById("confirm-tile-btn").addEventListener("click", () => {
        game.confirmTile();
      });
      document.getElementById("skip-move-btn").addEventListener("click", () => {
        if (game.phase === "rotate" && !game.anyRotationValid()) {
          let tileType = game.activeTile.type;
          let currentPlayer = game.getCurrentPlayer();
          currentPlayer.pool[tileType]++;
          game.logEvent("Jugador " + currentPlayer.name + ": retorna peça " + tileNamesCat[tileType] + " per no ser vàlida");
          game.activeTile = null;
          game.phase = "move";
          game.validCells = game.getMovableCells();
          document.getElementById("tile-controls").style.display = "none";
          document.getElementById("move-controls").style.display = "flex";
          game.renderBoard();
        } else if (game.phase === "move") {
          game.endTurn();
        }
      });
      document.getElementById("config-start-btn").addEventListener("click", () => {
        startGame();
      });
      document.getElementById("config-reset-btn").addEventListener("click", () => {
        resetGame();
      });
    };
  </script>
</body>
</html>
