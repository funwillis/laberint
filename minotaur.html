<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Labyrinth - Tile Game</title>
  <!-- Using the Cinzel font for a classical Greek feel -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel&display=swap" rel="stylesheet">
  <style>
    /* =================== General Styles =================== */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Cinzel', serif;
      background: linear-gradient(135deg, #fdfcfb, #e2d1c3);
      color: #3e2723;
    }
    /* =================== Layout: 3 Columns =================== */
    #game-container {
      display: flex;
      height: 100vh;
      box-sizing: border-box;
      padding: 5px;
    }
    /* =================== Spinner Style =================== */
    #spinner {
      display: none;
      width: 30px;
      height: 30px;
      border: 4px solid #ccc;
      border-top: 4px solid #8d6e63;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    /* =================== Left Panel: Controls =================== */
    #control-panel {
      width: 300px;
      padding: 15px;
      background: #f8f1e4;
      border-right: 4px solid #8d6e63;
      box-shadow: 4px 0 10px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #control-panel h2, #control-panel h3 {
      color: #5d4037;
      margin: 5px 0;
    }
    #control-panel h2 {
      font-size: 24px;
    }
    #turn-info {
      margin-bottom: 10px;
    }
    #turn-info p {
      background: linear-gradient(45deg, rgba(255,215,0,0.3), rgba(255,215,0,0.1));
      padding: 5px 10px;
      border-radius: 8px;
      font-weight: bold;
      text-align: center;
      border: 1px solid gold;
    }
    /* =================== Choice Panel =================== */
    #choice-controls {
      display: none;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    #choice-controls button {
      margin: 5px;
      padding: 10px 15px;
      background: #8d6e63;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s ease;
    }
    #choice-controls button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    #choice-controls button:hover:not(:disabled) {
      background: #6d4c41;
    }
    #finalize-btn {
      margin: 5px;
      padding: 10px 15px;
      background: #8d6e63;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s ease;
      display: none;
    }
    #finalize-btn:hover {
      background: #6d4c41;
    }
    /* =================== Center Panel: Message and Board =================== */
    #board-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 10px;
    }
    #message {
      margin-bottom: 15px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
      min-height: 40px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(12, 50px);
      grid-template-rows: repeat(12, 50px);
      gap: 2px;
      background: #333;
      padding: 10px;
      border: 4px solid #8d6e63;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      position: relative;
    }
    .cell {
      width: 50px;
      height: 50px;
      background: #fff;
      position: relative;
      box-shadow: inset 0 0 2px #999;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .cell.highlight {
      background: #c8e6c9;
    }
    /* =================== Player Markers =================== */
    .player {
      position: absolute;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2196F3; /* uniform blue */
      color: white;
      font-size: 12px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #fff;
      box-shadow: 0 0 8px rgba(0,0,0,0.5);
      z-index: 15;
    }
    /* Active marker glow changed to olive green (#556B2F) */
    .active-marker {
      box-shadow: 0 0 12px 4px #556B2F;
      transform: translate(-50%, -50%) scale(1.3);
      border-color: #556B2F;
      transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    }
    .cell-coord {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 10px;
      color: #666;
      z-index: 10;
    }
    /* =================== Tile Visuals =================== */
    .tile {
      width: 100%;
      height: 100%;
      background-size: cover;
      background-repeat: no-repeat;
      display: block;
      margin: auto;
    }
    .tile-entrance {
      background-color: #d2b48c;
      border: 2px solid #8b4513;
      border-radius: 4px;
    }
    .tile-exit {
      background-color: #ef9a9a;
      border: 2px solid #d32f2f;
      border-radius: 4px;
    }
    .tile-treasure {
      background-color: #ffe082;
      border: 2px solid #fbc02d;
      border-radius: 4px;
    }
    .tile-minotaur {
      background-color: #ce93d8;
      border: 2px solid #8e24aa;
      border-radius: 4px;
    }
    .tile-deadend {
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><line x1='50' y1='0' x2='50' y2='60' stroke='%235d4037' stroke-width='20' stroke-linecap='round'/><line x1='40' y1='60' x2='60' y2='60' stroke='%235d4037' stroke-width='20' stroke-linecap='round'/></svg>");
      background-size: 100% 100%;
      background-repeat: no-repeat;
    }
    .tile-cross {
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='40' y='0' width='20' height='100' fill='%235d4037'/><rect x='0' y='40' width='100' height='20' fill='%235d4037'/></svg>");
    }
    .tile-straight {
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='40' y='0' width='20' height='100' fill='%235d4037'/></svg>");
    }
    .tile-t {
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='40' y='0' width='20' height='60' fill='%235d4037'/><rect x='0' y='40' width='100' height='20' fill='%235d4037'/></svg>");
    }
    .tile-curve {
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='40' y='0' width='20' height='50' fill='%235d4037'/><rect x='50' y='40' width='50' height='20' fill='%235d4037'/></svg>");
    }
    /* =================== Control Panel Groups =================== */
    #choice-controls, #tile-controls, #move-controls {
      width: 100%;
      margin-top: 15px;
      display: none;
      flex-direction: column;
      align-items: center;
    }
    #skip-move-btn {
      padding: 10px 15px;
      background: #8d6e63;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s ease;
    }
    #skip-move-btn:hover { background: #6d4c41; }
    #tile-preview-container {
      width: 60px;
      height: 60px;
      margin: 10px;
      border: 2px dashed #8d6e63;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      position: relative;
      transition: border 0.3s ease;
    }
    /* Red overlay for invalid tile orientation */
    #invalid-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 0, 0, 0.3);
      color: red;
      font-size: 24px;
      font-weight: bold;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    #tile-preview-container.invalid #invalid-overlay {
      opacity: 1;
    }
    #tile-preview {
      width: 100%;
      height: 100%;
      background-size: cover;
      background-repeat: no-repeat;
      display: block;
    }
    /* =================== Right Panel: Configuration and Event Log =================== */
    #log-panel {
      width: 550px;
      display: flex;
      flex-direction: column;
      height: 100%;
      border-left: 4px solid #8d6e63;
      box-shadow: -4px 0 10px rgba(0,0,0,0.3);
    }
    #config-panel {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      border-bottom: 1px solid #8d6e63;
    }
    #config-panel h3 {
      margin-top: 0;
      text-align: center;
    }
    /* Configuration Buttons */
    #config-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }
    #config-table {
      width: 100%;
      border-collapse: collapse;
    }
    #config-table th, #config-table td {
      border: 1px solid #8d6e63;
      padding: 5px;
      text-align: center;
    }
    #config-table input {
      width: 64px;
    }
    .input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .arrow-container {
      display: flex;
      justify-content: center;
      gap: 2px;
      margin-top: 2px;
      flex-wrap: wrap;
    }
    .arrow-btn {
      font-size: 10px;
      line-height: 1;
      padding: 2px;
      width: 16px;
      height: 16px;
      text-align: center;
      border: 1px solid #8d6e63;
      background: #f8f1e4;
      cursor: pointer;
    }
    /* =================== Event Log =================== */
    #event-log-container {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
    }
    #event-log-container h3 {
      margin-top: 0;
      text-align: center;
    }
    #event-log {
      width: 100%;
    }
    /* =================== Game Buttons (Below Board) =================== */
    #game-buttons {
      margin-top: 15px;
      text-align: center;
    }
    .btn {
      padding: 10px 15px;
      margin: 10px;
      background: #8d6e63;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s ease;
    }
    .btn:hover { background: #6d4c41; }
    
    /* =================== Mobile Responsive Styles =================== */
    @media only screen and (max-width: 768px) {
      #game-container {
        flex-direction: column;
        height: auto;
        padding: 5px;
      }
      #control-panel, #board-container, #log-panel {
        width: 100%;
        margin: 5px 0;
      }
      #board {
        grid-template-columns: repeat(12, 30px);
        grid-template-rows: repeat(12, 30px);
        gap: 1px;
        padding: 5px;
        border-width: 2px;
      }
      .cell {
        width: 30px;
        height: 30px;
      }
      .player {
        width: 18px;
        height: 18px;
        border-width: 1px;
      }
      #turn-info p {
        font-size: 14px;
        padding: 4px 8px;
      }
      #message {
        font-size: 16px;
      }
      .btn {
        padding: 8px 12px;
        font-size: 14px;
      }
      #tile-preview-container {
        width: 40px;
        height: 40px;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Left Panel: Controls (always visible) -->
    <div id="control-panel">
      <div id="spinner"></div>
      <!-- Choice Panel for selecting action -->
      <div id="choice-controls">
        <button id="explore-btn" class="btn">Explorar</button>
        <button id="move-btn" class="btn">Moure</button>
        <button id="finalize-btn" class="btn" style="display:none;">Finalitzar torn</button>
      </div>
      <!-- Tile (explore) controls -->
      <div id="tile-controls">
        <h3>Peça Obtinguda</h3>
        <div id="tile-preview-container">
          <div id="tile-preview"></div>
          <div id="invalid-overlay">!</div>
        </div>
        <button id="rotate-btn" class="btn">Gira 90º</button>
        <!-- confirm-tile-btn is hidden (confirmation is by board click) -->
        <button id="confirm-tile-btn" class="btn" style="display:none;">Confirma peça</button>
        <!-- Tile-back button appears if no rotation is valid -->
        <button id="tile-back-btn" class="btn" style="display:none;">Cancelar exploració</button>
      </div>
      <!-- Move controls -->
      <div id="move-controls">
        <button id="skip-move-btn" class="btn">Ometre moviment</button>
      </div>
      <div id="turn-info"></div>
    </div>
    <!-- Center Panel: Message and Board -->
    <div id="board-container">
      <div id="message"></div>
      <div id="board"></div>
    </div>
    <!-- Right Panel: Configuration and Event Log -->
    <div id="log-panel">
      <div id="config-panel">
        <h3>Configuració Inicial</h3>
        <table id="config-table">
          <thead>
            <tr>
              <th>Tipus</th>
              <th>Previsualització</th>
              <th>Jugador 1</th>
              <th>Jugador 2</th>
              <th>Jugador 3</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Cruce</td>
              <td class="preview-cell"><div class="tile tile-cross" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="cross">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="cross">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="cross">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
            <!-- Similar rows for Curva, Bifurcació, Recta, Tancat -->
            <tr>
              <td>Curva</td>
              <td class="preview-cell"><div class="tile tile-curve" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="curve">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="curve">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="curve">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
            <tr>
              <td>Bifurcació</td>
              <td class="preview-cell"><div class="tile tile-t" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="t">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="t">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="t">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
            <tr>
              <td>Recta</td>
              <td class="preview-cell"><div class="tile tile-straight" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="straight">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="straight">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="straight">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
            <tr>
              <td>Tancat</td>
              <td class="preview-cell"><div class="tile tile-deadend" style="width:50px;height:50px;"></div></td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="deadend">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="deadend">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
              <td>
                <div class="input-container">
                  <input type="number" min="0" value="10" data-type="deadend">
                  <div class="arrow-container">
                    <button class="arrow-btn" onclick="propagateLeft(this)">←</button>
                    <button class="arrow-btn" onclick="propagateRight(this)">→</button>
                    <button class="arrow-btn" onclick="propagateUp(this)">↑</button>
                    <button class="arrow-btn" onclick="propagateDown(this)">↓</button>
                  </div>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
        <div id="config-buttons">
          <button id="config-start-btn" class="btn">Iniciar</button>
          <button id="config-reset-btn" class="btn" disabled>Reinicia</button>
        </div>
      </div>
      <div id="event-log-container">
        <h3>Log d'Events</h3>
        <div id="event-log"></div>
      </div>
    </div>
  </div>
  
  <script>
    // Declare global variable
    var game = null;
    
    // Global propagation functions
    function propagateLeft(btn) {
      let td = btn.closest("td");
      let input = td.querySelector("input");
      let value = input.value;
      let tr = td.closest("tr");
      let cells = Array.from(tr.cells);
      let currentIndex = td.cellIndex;
      cells.forEach((cell, index) => {
        if (index < currentIndex) {
          let inp = cell.querySelector("input");
          if (inp) { inp.value = value; }
        }
      });
    }
    function propagateRight(btn) {
      let td = btn.closest("td");
      let input = td.querySelector("input");
      let value = input.value;
      let tr = td.closest("tr");
      let cells = Array.from(tr.cells);
      let currentIndex = td.cellIndex;
      cells.forEach((cell, index) => {
        if (index > currentIndex) {
          let inp = cell.querySelector("input");
          if (inp) { inp.value = value; }
        }
      });
    }
    function propagateUp(btn) {
      let td = btn.closest("td");
      let input = td.querySelector("input");
      let value = input.value;
      let tr = td.closest("tr");
      let tbody = tr.closest("tbody");
      let rows = Array.from(tbody.rows);
      let currentRowIndex = tr.sectionRowIndex;
      rows.forEach((row, index) => {
        if (index < currentRowIndex) {
          let cell = row.cells[td.cellIndex];
          if (cell) {
            let inp = cell.querySelector("input");
            if (inp) { inp.value = value; }
          }
        }
      });
    }
    function propagateDown(btn) {
      let td = btn.closest("td");
      let input = td.querySelector("input");
      let value = input.value;
      let tr = td.closest("tr");
      let tbody = tr.closest("tbody");
      let rows = Array.from(tbody.rows);
      let currentRowIndex = tr.sectionRowIndex;
      rows.forEach((row, index) => {
        if (index > currentRowIndex) {
          let cell = row.cells[td.cellIndex];
          if (cell) {
            let inp = cell.querySelector("input");
            if (inp) { inp.value = value; }
          }
        }
      });
    }
    
    // Global mappings and base definitions
    const playerColors = {
      player1: "#2196F3",
      player2: "#2196F3",
      player3: "#2196F3"
    };
    const tileNamesCat = {
      cross: "creu",
      curve: "angle recte",
      t: "bifurcació",
      straight: "recta",
      deadend: "tancat"
    };
    const deltas = {
      N: { dx: 0, dy: -1 },
      E: { dx: 1, dy: 0 },
      S: { dx: 0, dy: 1 },
      W: { dx: -1, dy: 0 }
    };
    const baseTiles = {
      cross: { edges: { N: true, E: true, S: true, W: true } },
      curve: { edges: { N: true, E: true, S: false, W: false } },
      t: { edges: { N: true, E: true, S: false, W: true } },
      straight: { edges: { N: true, E: false, S: true, W: false } },
      deadend: { edges: { N: true, E: false, S: false, W: false } }
    };
    
    // Global class definitions
    class Tile {
      constructor(type, edges, special = null) {
        this.type = type;
        this.edges = Object.assign({}, edges);
        this.special = special;
        this.rotation = 0;
      }
      rotate() {
        const { N, E, S, W } = this.edges;
        this.edges = { N: W, E: N, S: E, W: S };
        this.rotation = (this.rotation + 90) % 360;
      }
      clone() {
        const newTile = new Tile(this.type, Object.assign({}, this.edges), this.special);
        newTile.rotation = this.rotation;
        return newTile;
      }
    }
    
    class Cell {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.tile = null;
        this.player = null;
      }
    }
    
    class Player {
      constructor(name, x, y, cssClass) {
        this.name = name;
        this.x = x;
        this.y = y;
        this.cssClass = cssClass;
        this.pool = {};
      }
    }
    
    class Game {
      constructor() {
        this.size = 12;
        this.board = [];
        this.players = [];
        this.currentPlayerIndex = 0;
        // Phases: "choose", "rotate", "place", "move"
        this.phase = "idle";
        this.validCells = [];
        this.activeTile = null;
        this.events = [];
        // Flags for actions in the current turn.
        this.hasExplored = false;
        this.hasMoved = false;
        this.initBoard();
        this.initSpecialTiles();
        this.initPlayers();
        this.renderBoard();
        this.updateTurnInfo();
        this.logEvent("Inici del joc");
        this.startTurn();
      }
      initBoard() {
        for (let y = 1; y <= this.size; y++) {
          const row = [];
          for (let x = 1; x <= this.size; x++) {
            row.push(new Cell(x, y));
          }
          this.board.push(row);
        }
      }
      initSpecialTiles() {
        const placeSpecial = (x, y, specialType, baseType, edges) => {
          const cell = this.getCell(x, y);
          cell.tile = new Tile(baseType, edges, specialType);
        };
        placeSpecial(1, 12, 'entrance', 'entrance', {N: true, E: true, S: false, W: false});
        placeSpecial(12, 1, 'entrance', 'entrance', {N: false, E: false, S: true, W: true});
        placeSpecial(12, 12, 'entrance', 'entrance', {N: true, E: false, S: false, W: true});
        placeSpecial(1, 1, 'exit', 'exit', {N: false, E: true, S: true, W: false});
        [[4,4], [4,9], [9,4], [9,9]].forEach(coord => {
          placeSpecial(coord[0], coord[1], 'treasure', 'treasure', {N: true, E: false, S: false, W: false});
        });
        [[6,6], [6,7], [7,6], [7,7]].forEach(coord => {
          placeSpecial(coord[0], coord[1], 'minotaur', 'minotaur', {N: true, E: true, S: true, W: false});
        });
      }
      initPlayers() {
        this.players.push(new Player("Jugador 1", 1, 12, "player1"));
        this.players.push(new Player("Jugador 2", 12, 1, "player2"));
        this.players.push(new Player("Jugador 3", 12, 12, "player3"));
        this.players.forEach(p => {
          this.getCell(p.x, p.y).player = p;
        });
      }
      getCell(x, y) {
        if (x < 1 || x > this.size || y < 1 || y > this.size) return null;
        return this.board[y - 1][x - 1];
      }
      renderBoard() {
        const boardDiv = document.getElementById("board");
        boardDiv.innerHTML = "";
        const currentPlayer = this.getCurrentPlayer();
        for (let y = 1; y <= this.size; y++) {
          for (let x = 1; x <= this.size; x++) {
            const cell = this.getCell(x, y);
            const cellDiv = document.createElement("div");
            cellDiv.classList.add("cell");
            if (cell.player) {
              const playerDiv = document.createElement("div");
              playerDiv.classList.add("player");
              // Display "J1", "J2", "J3" based on player's name.
              playerDiv.innerText = cell.player.name.replace("Jugador ", "J");
              if (cell.player.name === currentPlayer.name) {
                playerDiv.classList.add("active-marker");
              }
              cellDiv.appendChild(playerDiv);
            }
            cellDiv.dataset.x = x;
            cellDiv.dataset.y = y;
            const coordSpan = document.createElement("span");
            coordSpan.classList.add("cell-coord");
            coordSpan.innerText = x + "," + y;
            cellDiv.appendChild(coordSpan);
            if (cell.tile) {
              const tileDiv = document.createElement("div");
              tileDiv.classList.add("tile");
              if (cell.tile.special) {
                tileDiv.classList.add("tile-" + cell.tile.special);
              } else {
                tileDiv.classList.add("tile-" + cell.tile.type);
              }
              tileDiv.style.transform = "rotate(" + cell.tile.rotation + "deg)";
              cellDiv.appendChild(tileDiv);
            }
            if (this.validCells.find(c => c.x === x && c.y === y)) {
              cellDiv.classList.add("highlight");
            }
            cellDiv.addEventListener("click", () => this.handleCellClick(x, y));
            boardDiv.appendChild(cellDiv);
          }
        }
      }
      updateTurnInfo() {
        const infoDiv = document.getElementById("turn-info");
        if (infoDiv) {
          const currentPlayer = this.getCurrentPlayer();
          infoDiv.innerHTML = `<p>Torn actiu: ${currentPlayer.name}</p>`;
        }
      }
      setMessage(msg) {
        document.getElementById("message").innerText = msg;
      }
      logEvent(message) {
        const snapshot = this.saveState();
        this.events.unshift({ message, snapshot });
        this.updateLog();
        updateConfigTable();
      }
      updateLog() {
        const logDiv = document.getElementById("event-log");
        logDiv.innerHTML = "";
        this.events.forEach((evt, index) => {
          const entry = document.createElement("div");
          entry.style.borderBottom = "1px solid #8d6e63";
          entry.style.padding = "5px";
          entry.style.display = "flex";
          entry.style.justifyContent = "space-between";
          entry.style.alignItems = "center";
          const msgSpan = document.createElement("span");
          msgSpan.innerText = evt.message;
          const rewindBtn = document.createElement("button");
          rewindBtn.className = "btn";
          rewindBtn.style.padding = "2px 5px";
          rewindBtn.style.fontSize = "12px";
          rewindBtn.innerText = "Rebobina";
          rewindBtn.onclick = () => { this.rewindToEvent(index); };
          entry.appendChild(msgSpan);
          entry.appendChild(rewindBtn);
          logDiv.appendChild(entry);
        });
      }
      rewindToEvent(index) {
        const evt = this.events[index];
        if (evt) {
          this.restoreState(evt.snapshot);
          this.logEvent("Rebobinat a: " + evt.message);
        }
      }
      saveState() {
        return {
          currentPlayerIndex: this.currentPlayerIndex,
          phase: this.phase,
          board: this.board.map(row => row.map(cell => ({
            x: cell.x,
            y: cell.y,
            tile: cell.tile ? {
              type: cell.tile.type,
              edges: Object.assign({}, cell.tile.edges),
              special: cell.tile.special,
              rotation: cell.tile.rotation
            } : null,
            player: cell.player ? {
              name: cell.player.name,
              x: cell.player.x,
              y: cell.player.y,
              cssClass: cell.player.cssClass
            } : null
          }))),
          players: this.players.map(p => ({
            name: p.name,
            x: p.x,
            y: p.y,
            cssClass: p.cssClass,
            pool: Object.assign({}, p.pool)
          })),
          activeTile: this.activeTile ? {
            type: this.activeTile.type,
            edges: Object.assign({}, this.activeTile.edges),
            special: this.activeTile.special,
            rotation: this.activeTile.rotation
          } : null
        };
      }
      restoreState(state) {
        this.currentPlayerIndex = state.currentPlayerIndex;
        this.phase = state.phase;
        this.board = state.board.map(rowData => {
          return rowData.map(cellData => {
            const cell = new Cell(cellData.x, cellData.y);
            if (cellData.tile) {
              cell.tile = new Tile(cellData.tile.type, cellData.tile.edges, cellData.tile.special);
              cell.tile.rotation = cellData.tile.rotation;
            }
            if (cellData.player) {
              cell.player = new Player(cellData.player.name, cellData.player.x, cellData.player.y, cellData.player.cssClass);
              cell.player.pool = Object.assign({}, cellData.player.pool);
            }
            return cell;
          });
        });
        this.players = state.players.map(pData => {
          let p = new Player(pData.name, pData.x, pData.y, pData.cssClass);
          p.pool = Object.assign({}, pData.pool);
          return p;
        });
        if (state.activeTile) {
          this.activeTile = new Tile(state.activeTile.type, state.activeTile.edges, state.activeTile.special);
          this.activeTile.rotation = state.activeTile.rotation;
        } else {
          this.activeTile = null;
        }
        this.renderBoard();
        this.updateTurnInfo();
      }
      getCurrentPlayer() {
        return this.players[this.currentPlayerIndex];
      }
      getCurrentPlayerCell() {
        const p = this.getCurrentPlayer();
        return this.getCell(p.x, p.y);
      }
      getAdjacentCoords(x, y) {
        return [
          { x: x, y: y - 1, dir: "N" },
          { x: x + 1, y: y, dir: "E" },
          { x: x, y: y + 1, dir: "S" },
          { x: x - 1, y: y, dir: "W" }
        ].filter(coord => this.getCell(coord.x, coord.y) !== null);
      }
      getDirection(from, to) {
        if (to.x === from.x && to.y === from.y - 1) return "N";
        if (to.x === from.x + 1 && to.y === from.y) return "E";
        if (to.x === from.x && to.y === from.y + 1) return "S";
        if (to.x === from.x - 1 && to.y === from.y) return "W";
        return null;
      }
      getOpposite(dir) {
        const opposites = { N: "S", E: "W", S: "N", W: "E" };
        return opposites[dir];
      }
      isActiveTilePlaceable() {
        if (!this.activeTile) return false;
        return this.getExplorableCells().length > 0;
      }
      getExplorableCells() {
        const current = this.getCurrentPlayerCell();
        const adj = this.getAdjacentCoords(current.x, current.y);
        return adj.filter(coord => {
          const cell = this.getCell(coord.x, coord.y);
          if (!cell || cell.tile) return false;
          if (!current.tile.edges[coord.dir] || !this.activeTile.edges[this.getOpposite(coord.dir)]) {
            return false;
          }
          if (this.activeTile.type === "curve") {
            let activeEdges = Object.keys(this.activeTile.edges).filter(d => this.activeTile.edges[d]);
            let used = this.getOpposite(coord.dir);
            let others = activeEdges.filter(d => d !== used);
            if (others.length > 0) {
              let otherDir = others[0];
              let delta = deltas[otherDir];
              if (!this.getCell(coord.x + delta.dx, coord.y + delta.dy)) return false;
            }
          }
          return true;
        });
      }
      getMovableCells() {
        const current = this.getCurrentPlayerCell();
        const currentTile = current.tile;
        if (!currentTile) return [];
        const adj = this.getAdjacentCoords(current.x, current.y);
        return adj.filter(coord => {
          const cell = this.getCell(coord.x, coord.y);
          if (!cell || !cell.tile) return false;
          const dir = this.getDirection(current, coord);
          return currentTile.edges[dir] && cell.tile.edges[this.getOpposite(dir)];
        });
      }
      anyRotationValid() {
        let current = this.getCurrentPlayerCell();
        let freeAdj = this.getAdjacentCoords(current.x, current.y).filter(coord => {
          let cell = this.getCell(coord.x, coord.y);
          return cell && !cell.tile;
        });
        for (let i = 0; i < 4; i++) {
          let testTile = this.activeTile.clone();
          for (let j = 0; j < i; j++) {
            testTile.rotate();
          }
          for (let coord of freeAdj) {
            if (current.tile.edges[coord.dir] && testTile.edges[this.getOpposite(coord.dir)]) {
              if (testTile.type === "curve") {
                let activeEdges = Object.keys(testTile.edges).filter(d => testTile.edges[d]);
                let used = this.getOpposite(coord.dir);
                let others = activeEdges.filter(d => d !== used);
                if (others.length > 0) {
                  let otherDir = others[0];
                  let delta = deltas[otherDir];
                  if (!this.getCell(coord.x + delta.dx, coord.y + delta.dy)) {
                    continue;
                  }
                }
              }
              return true;
            }
          }
        }
        return false;
      }
      updateTileFeedback() {
        // Update feedback immediately after drawing or rotation.
        this.updateTilePreview();
        this.validateActiveTile();
        if (this.activeTile && this.anyRotationValid()) {
          this.validCells = this.getExplorableCells();
          // Set phase to "place" so board clicks confirm placement.
          this.phase = "place";
        } else {
          this.phase = "rotate";
        }
        this.renderBoard();
      }
      validateActiveTile() {
        if (this.activeTile) {
          if (!this.anyRotationValid()) {
            // Show red invalid overlay and show tile-back button.
            document.getElementById("tile-preview-container").classList.add("invalid");
            document.getElementById("confirm-tile-btn").style.display = "none";
            document.getElementById("tile-back-btn").style.display = "inline-block";
          } else {
            document.getElementById("tile-preview-container").classList.remove("invalid");
            document.getElementById("confirm-tile-btn").style.display = "none"; // confirmation is by board click
            document.getElementById("tile-back-btn").style.display = "none";
          }
        }
      }
      rotateActiveTile() {
        if (this.activeTile) {  // Removed phase check to allow rotation in "place" phase as well.
          this.activeTile.rotate();
          this.updateTileFeedback();
        }
      }
      updateTilePreview() {
        const preview = document.getElementById("tile-preview");
        preview.innerHTML = "";
        if (this.activeTile) {
          const tileElem = document.createElement("div");
          tileElem.classList.add("tile");
          if (this.activeTile.type === "deadend") {
            tileElem.classList.add("tile-deadend");
          } else if (this.activeTile.special) {
            tileElem.classList.add("tile-" + this.activeTile.special);
          } else {
            tileElem.classList.add("tile-" + this.activeTile.type);
          }
          tileElem.style.transform = "rotate(" + this.activeTile.rotation + "deg)";
          preview.appendChild(tileElem);
        }
      }
      drawTile() {
        let pool = this.getCurrentPlayer().pool;
        let total = 0;
        for (let type in pool) {
          total += pool[type];
        }
        if (total <= 0) return null;
        let rnd = Math.random() * total;
        let chosenType = null;
        for (let type in pool) {
          if (pool[type] > 0) {
            if (rnd < pool[type]) {
              chosenType = type;
              break;
            }
            rnd -= pool[type];
          }
        }
        this.getCurrentPlayer().pool[chosenType]--;
        let tile = new Tile(chosenType, baseTiles[chosenType].edges);
        let rotations = Math.floor(Math.random() * 4);
        for (let i = 0; i < rotations; i++) {
          tile.rotate();
        }
        return tile;
      }
      startTurn() {
        this.phase = "choose";
        this.activeTile = null;
        this.validCells = [];
        this.hasExplored = false;
        this.hasMoved = false;
        this.updateTurnInfo();
        this.renderBoard();
        this.showChoice();
      }
      updateChoiceControls() {
        const exploreBtn = document.getElementById("explore-btn");
        const moveBtn = document.getElementById("move-btn");
        const finalizeBtn = document.getElementById("finalize-btn");
        document.getElementById("choice-controls").style.display = "flex";
        const current = this.getCurrentPlayerCell();
        const freeAdjacent = this.getAdjacentCoords(current.x, current.y).filter(coord => {
          let cell = this.getCell(coord.x, coord.y);
          return cell && !cell.tile;
        });
        const moveAvailable = this.getMovableCells().length > 0;
        let canExplore = (freeAdjacent.length > 0) && (!this.hasExplored);
        let canMove = (moveAvailable) && (!this.hasMoved);
        if (!canMove) { moveBtn.style.display = "none"; } else { moveBtn.style.display = "inline-block"; }
        if (!canExplore) { exploreBtn.style.display = "none"; } else { exploreBtn.style.display = "inline-block"; }
        exploreBtn.disabled = !canExplore;
        moveBtn.disabled = !canMove;
        if (!canExplore && !canMove) {
          exploreBtn.style.display = "none";
          moveBtn.style.display = "none";
          finalizeBtn.style.display = "block";
          this.setMessage("No hi ha accions disponibles. Prem 'Finalitzar torn' per acabar.");
        } else {
          finalizeBtn.style.display = "none";
          this.setMessage("Torn de " + this.getCurrentPlayer().name + ". Escull: Explorar o Moure.");
        }
      }
      showChoice() {
        document.getElementById("tile-controls").style.display = "none";
        document.getElementById("move-controls").style.display = "none";
        this.updateChoiceControls();
      }
      exploreTurn() {
        this.hasExplored = true;
        document.getElementById("explore-btn").disabled = true;
        document.getElementById("move-btn").disabled = true;
        document.getElementById("choice-controls").style.display = "none";
        this.phase = "rotate";
        this.activeTile = this.drawTile();
        if (!this.activeTile) {
          this.setMessage("No tens més peces per explorar.");
          return;
        }
        document.getElementById("tile-controls").style.display = "flex";
        document.getElementById("move-controls").style.display = "none";
        this.updateTileFeedback();
        this.setMessage("Torn de " + this.getCurrentPlayer().name + ". Peça obtinguda: " + tileNamesCat[this.activeTile.type] + ". Pots girar-la i, si és vàlida, clicar sobre la casella destacada per col·locar-la.");
      }
      moveTurn() {
        this.hasMoved = true;
        document.getElementById("explore-btn").disabled = true;
        document.getElementById("move-btn").disabled = true;
        document.getElementById("choice-controls").style.display = "none";
        const moveCells = this.getMovableCells();
        if (moveCells.length === 0) {
          this.setMessage("No pots moure't. Torna a escollir.");
          this.showChoice();
          return;
        }
        this.phase = "move";
        this.validCells = moveCells;
        document.getElementById("tile-controls").style.display = "none";
        document.getElementById("move-controls").style.display = "flex";
        this.setMessage("Torn de " + this.getCurrentPlayer().name + ". Pots moure't.");
        this.renderBoard();
      }
      handleCellClick(x, y) {
        if (this.phase === "place") {
          if (!this.validCells.find(c => c.x === x && c.y === y)) return;
          const cell = this.getCell(x, y);
          cell.tile = this.activeTile;
          const currentPlayer = this.getCurrentPlayer();
          const remaining = currentPlayer.pool[this.activeTile.type] || 0;
          this.logEvent("Jugador " + currentPlayer.name + ": Peça " + tileNamesCat[this.activeTile.type] + " col·locada a (" + x + "," + y + "). Queden: " + remaining);
          this.activeTile = null;
          this.validCells = [];
          this.phase = "move";
          this.validCells = this.getMovableCells();
          document.getElementById("tile-controls").style.display = "none";
          document.getElementById("move-controls").style.display = "flex";
          if (this.validCells.length === 0) {
            this.setMessage("Peça col·locada. No hi ha moviments disponibles. Fi de torn.");
            this.renderBoard();
            this.logEvent("Jugador " + currentPlayer.name + ": Peça col·locada sense moviments");
            setTimeout(() => this.endTurn(), 500);
          } else {
            this.setMessage("Peça col·locada. Ara tria on vols moure't.");
          }
          this.renderBoard();
        } else if (this.phase === "move") {
          if (!this.validCells.find(c => c.x === x && c.y === y)) return;
          const currentPlayer = this.getCurrentPlayer();
          this.getCell(currentPlayer.x, currentPlayer.y).player = null;
          currentPlayer.x = x;
          currentPlayer.y = y;
          this.getCell(x, y).player = currentPlayer;
          this.setMessage("El jugador " + currentPlayer.name + " s'ha mogut a (" + x + "," + y + "). Fi de torn.");
          this.renderBoard();
          this.logEvent("Jugador " + currentPlayer.name + " mogut a (" + x + "," + y + ")");
          setTimeout(() => this.endTurn(), 500);
        }
      }
      endTurn() {
        document.getElementById("spinner").style.display = "block";
        this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;
        setTimeout(() => { 
          document.getElementById("spinner").style.display = "none";
          this.startTurn(); 
        }, 500);
      }
      updateTileFeedback() {
        // Update feedback immediately after drawing or rotation.
        this.updateTilePreview();
        this.validateActiveTile();
        if (this.activeTile && this.anyRotationValid()) {
          this.validCells = this.getExplorableCells();
          this.phase = "place";
        } else {
          this.phase = "rotate";
        }
        this.renderBoard();
      }
      anyRotationValid() {
        let current = this.getCurrentPlayerCell();
        let freeAdj = this.getAdjacentCoords(current.x, current.y).filter(coord => {
          let cell = this.getCell(coord.x, coord.y);
          return cell && !cell.tile;
        });
        for (let i = 0; i < 4; i++) {
          let testTile = this.activeTile.clone();
          for (let j = 0; j < i; j++) {
            testTile.rotate();
          }
          for (let coord of freeAdj) {
            if (current.tile.edges[coord.dir] && testTile.edges[this.getOpposite(coord.dir)]) {
              if (testTile.type === "curve") {
                let activeEdges = Object.keys(testTile.edges).filter(d => testTile.edges[d]);
                let used = this.getOpposite(coord.dir);
                let others = activeEdges.filter(d => d !== used);
                if (others.length > 0) {
                  let otherDir = others[0];
                  let delta = deltas[otherDir];
                  if (!this.getCell(coord.x + delta.dx, coord.y + delta.dy)) {
                    continue;
                  }
                }
              }
              return true;
            }
          }
        }
        return false;
      }
    }
    
    // Configuration functions
    function readConfiguration() {
      const inputs = document.querySelectorAll("#config-table input");
      let pools = { "Jugador 1": {}, "Jugador 2": {}, "Jugador 3": {} };
      inputs.forEach(input => {
        const type = input.getAttribute("data-type");
        let td = input.closest("td");
        let cellIndex = td ? td.cellIndex : -1;
        let player;
        if (cellIndex === 2) player = "Jugador 1";
        else if (cellIndex === 3) player = "Jugador 2";
        else if (cellIndex === 4) player = "Jugador 3";
        if (player) { pools[player][type] = parseInt(input.value, 10); }
      });
      return pools;
    }
    
    function disableConfiguration() {
      const inputs = document.querySelectorAll("#config-table input");
      inputs.forEach(input => input.disabled = true);
      document.getElementById("config-start-btn").disabled = true;
    }
    
    function enableConfigurationButtons(startEnabled) {
      document.getElementById("config-start-btn").disabled = !startEnabled;
      document.getElementById("config-reset-btn").disabled = startEnabled;
    }
    
    function updateConfigTable() {
      let inputs = document.querySelectorAll("#config-table input");
      inputs.forEach(input => {
        let type = input.getAttribute("data-type");
        let td = input.closest("td");
        let playerIndex = td.cellIndex - 2;
        if (game && game.players && game.players[playerIndex]) {
          input.value = game.players[playerIndex].pool[type];
        }
      });
    }
    
    function resetGame() {
      location.reload();
    }
    
    function startGame() {
      const pools = readConfiguration();
      game = new Game();
      game.players.forEach(player => {
        player.pool = Object.assign({}, pools[player.name]);
      });
      disableConfiguration();
      enableConfigurationButtons(false);
      game.startTurn();
    }
    
    // Attach event listeners after DOM is loaded.
    window.onload = function() {
      document.getElementById("config-start-btn").addEventListener("click", startGame);
      document.getElementById("config-reset-btn").addEventListener("click", resetGame);
      
      document.getElementById("rotate-btn").addEventListener("click", () => {
        game.rotateActiveTile();
      });
      document.getElementById("confirm-tile-btn").addEventListener("click", () => {
        // Not used: confirmation is by board click.
      });
      document.getElementById("tile-back-btn").addEventListener("click", () => {
        let tileType = game.activeTile.type;
        let currentPlayer = game.getCurrentPlayer();
        currentPlayer.pool[tileType]++;
        game.logEvent("Jugador " + currentPlayer.name + ": retorna peça " + tileNamesCat[tileType] + " per no ser vàlida");
        game.activeTile = null;
        game.phase = "move";
        game.validCells = game.getMovableCells();
        document.getElementById("tile-controls").style.display = "none";
        document.getElementById("move-controls").style.display = "flex";
        game.renderBoard();
        game.hasExplored = true;
      });
      document.getElementById("skip-move-btn").addEventListener("click", () => {
        if (game.phase === "rotate" && !game.anyRotationValid()) {
          let tileType = game.activeTile.type;
          let currentPlayer = game.getCurrentPlayer();
          currentPlayer.pool[tileType]++;
          game.logEvent("Jugador " + currentPlayer.name + ": retorna peça " + tileNamesCat[tileType] + " per no ser vàlida");
          game.activeTile = null;
          game.phase = "move";
          game.validCells = game.getMovableCells();
          document.getElementById("tile-controls").style.display = "none";
          document.getElementById("move-controls").style.display = "flex";
          game.renderBoard();
        } else if (game.phase === "move") {
          game.endTurn();
        }
      });
      
      document.getElementById("explore-btn").addEventListener("click", () => {
        if (document.getElementById("explore-btn").disabled) {
          game.setMessage("No pots explorar en aquesta situació.");
        } else {
          game.exploreTurn();
        }
      });
      document.getElementById("move-btn").addEventListener("click", () => {
        if (document.getElementById("move-btn").disabled) {
          game.setMessage("No pots moure't en aquesta situació.");
        } else {
          game.moveTurn();
        }
      });
      document.getElementById("finalize-btn").addEventListener("click", () => {
        game.endTurn();
      });
    };
  </script>
</body>
</html>
